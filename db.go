package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

const JSONDatabaseURL = "https://raw.githubusercontent.com/github/gemoji/master/db/emoji.json"

type Generator struct {
	buf bytes.Buffer
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func generateDatabaseFile() ([]byte, error) {
	resp, err := http.Get(JSONDatabaseURL)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GET %s returned status code %d, expected %d", JSONDatabaseURL, resp.StatusCode, http.StatusOK)
	}

	var emojis []Emoji
	if err := json.NewDecoder(resp.Body).Decode(&emojis); err != nil {
		return nil, err
	}

	g := Generator{}
	g.Printf("// Code generated by \"emoji %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], ""))
	g.Printf("\n")
	g.Printf("package main")
	g.Printf("\n")

	g.Printf("var emojis = []Emoji{\n")
	for _, emoji := range emojis {
		g.Printf("\t{\n")
		g.Printf("\t\tEmoji: %s,\n", strconv.Quote(emoji.Emoji))
		g.Printf("\t\tDescription: %s,\n", strconv.Quote(emoji.Description))
		g.Printf("\t\tCategory: %s,\n", strconv.Quote(emoji.Category))
		if len(emoji.Aliases) > 0 {
			g.Printf("\t\tAliases: []string{\n")
			for _, alias := range emoji.Aliases {
				g.Printf("\t\t\t%s,\n", strconv.Quote(alias))

			}
			g.Printf("\t\t},\n")
		}
		if len(emoji.Tags) > 0 {
			g.Printf("\t\tTags: []string{\n")
			for _, tag := range emoji.Tags {
				g.Printf("\t\t\t%s,\n", strconv.Quote(tag))

			}
			g.Printf("\t\t},\n")
		}
		g.Printf("\t\tUnicodeVersion: %s,\n", strconv.Quote(emoji.UnicodeVersion))
		g.Printf("\t\tIosVersion: %s,\n", strconv.Quote(emoji.IosVersion))
		g.Printf("\t},\n")
	}
	g.Printf("}\n")

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		return g.buf.Bytes(), err
	}

	return src, nil
}
